{
  "version": "2.0.0",
  "cells": [
    {
      "type": "markdown",
      "content": [
        "# Arrays in IDL",
        "___"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "### **What is an IDL array**",
        "An **element** is an individual \"item\". It represents a single unit of data that can be accessed, manipulated, or referenced independently. Elements in IDL are sometimes referred to as **scalars**.",
        "",
        "An **IDL array** is a data structure that stores a collection of **elements**.",
        "- The **elements** must all be the same **data type**. For example, all integers, all floats, or all strings.",
        "- The **elements** are stored in a contiguous block of memory.  ",
        "- The **array** is accessed and modified using an **index** (or several indices for **multi-dimensional** arrays).",
        "- Math operations using arrays are done as **atomic** (or **vector-based**) operations, meaning that the operation is applied to all elements, without needing to loop.",
        "",
        "IDL arrays are essentially **C/C++ arrays** with easy ways to access and modify elements. IDL arrays are very fast, with speeds approaching C, **but without any of the headaches** that come from using arrays in C. This fact, along with IDL's field-tested math libraries, combine to make IDL arrays some of the **fastest** while maintaining **ease of use**.",
        "___"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "### **Creating an array**  "
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "IDL provides several ways to create arrays:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "Creating a one-dimensional (vector), 2D, and 3D array."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "Array1D = [1, 2, 3]",
        "Array2D = [ [1, 2, 3], $",
        "            [4, 5, 6] ]",
        "Array3D = [ $",
        "  [ [1, 2, 3], $",
        "    [4, 5, 6]], $",
        "  [ [7, 8, 9], $",
        "    [10, 11, 12]] $",
        "  ]",
        "; ... onto N",
        "",
        "print, `1 Dimensional Array1D`",
        "print, Array1D",
        "print, `2 Dimensional Array2D`",
        "print, Array2D",
        "print, `3 Dimensional Array3D`",
        "print, Array3D"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "> One Dimensional arrays are used the most, so we will focus on them. Please use the format that best fits your data."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "You can also create an array using **IDL range notation**",
        "",
        "**IDL range notation** generates numbers into an array following the format [`start`:`end`:`step`] where:",
        "- `start`: is the start of the sequence (inclusive)",
        "- `end`: is the end of the sequence (inclusive)",
        "- `step`: is an optional increment between each number in the sequence (default is 1).  ",
        "",
        "For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; create and print an array between 1 and 10",
        "[1:10]",
        "; create and print an array between 1 and 20 with a step of 2",
        "[1:20:2]",
        "; create an array between 0 and 1 with a step of 0.1",
        "arr = [0:1:0.1]"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; Try it out!"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "You can also use built-in functions to create array of various types and dimensions. For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; A 3D array with dimensions 3 x 1024 x 768, filled with zeroes.",
        "array0 = FLTARR(3, 1024, 768)",
        "help, array0",
        "",
        "; Float generation 0, 1, 2, 3, 4",
        "array1 = FINDGEN(5)",
        "",
        "; Int generation.",
        "array2 = INDGEN(5)",
        "",
        "; Long generation.",
        "array3 = LINDGEN(5)",
        "",
        "; Double generation.",
        "array4 = DINDGEN(5)",
        "",
        "; Replicate.",
        "; This replicates the first element a n amount of times.",
        "array5 = REPLICATE(\"IDL\", 4, 3)",
        "",
        "; The most generic function, where you can specify the dimensions and type as input variables.",
        "array6 = MAKE_ARRAY(3, 4, VALUE = 5, TYPE = 12)",
        "",
        "print, array1",
        "print, array2",
        "print, array3",
        "print, array4",
        "print, array5",
        "print, array6"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### **Defining an index**",
        "Let us take a moment to define and understand the concept of an **index**.  ",
        "  ",
        "#### An **Index** is a numerical representation of the position of an element within an array.  ",
        "Put a more human friendly way: A Index is the **position** of the data's spot in \"line\".  ",
        "",
        "Take this example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "SimpleArray = [5:10]",
        "",
        "print, SimpleArray"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "We can think of this Array data structure as looking like:  ",
        "|5|6|7|8|9|10|",
        "|-|-|-|-|-|-|  ",
        "",
        "But what distinguishes any of the elements from each other? It can't be by value. What if the array was all 1's?  ",
        "|1|1|1|1|1|1|",
        "|-|-|-|-|-|-|  ",
        "",
        "The only consistent differentiator for the computer is its location in memory, and therefore, its position."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "| `Data`  | 5 | 6 | 7 | 8 | 9 | 10 |",
        "|---------|---|---|---|---|---|----|",
        "| `Index` | 0 | 1 | 2 | 3 | 4 | 5  |  ",
        "",
        "That **position** is the **index**.  ",
        "",
        "**Notice** that **index** starts at 0. This is because IDL indexes start at 0.  ",
        "This is fairly standard for programming. However, do take care as human language typically indexes with 1: \"You ate the first apple in the box!\"",
        "> Computer languages zero index for a multitude of reasons. However, the main reasons is that computers can use that zero without any fuss and the legacy behind 0 indexing. That being said there are still some languages (like R) that choose to 1 index instead."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "#### **Exercise 1**",
        "**Using the array definition above**, what is the index of the value `5`?"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "<details>",
        "  <summary>Click to the Answer</summary>",
        "",
        "  **Answer**: </br>",
        "  `0`</br>",
        "  This is because the value `5` is stored at the \"first block\" of our array. This \"first block\" of our array has a index of 0 because IDL index's **start** at 0.</br>",
        "</details>  "
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### **Accessing an array**",
        "Arrays are stored so that their elements sit next to each other in memory. This means we can quickly access an element by referencing its **index**.  ",
        "",
        "We do that using square brackets `[]`. In fact, whenever you see square brackets `[]` it means we are attempting to use an **index**."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; declare our array using range notation",
        "example = [10:20]",
        "",
        "; access and print the second element.",
        "print, example[1]"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "You can also use **IDL range notation** to access variables. Remember that range notation has the format [`start`:`end`:`step`] where:",
        "- `start`: is the start of the sequence (inclusive)",
        "- `end`: is the end of the sequence (inclusive). You can use **\\*** to represent the last element.",
        "- `step`: is an optional increment between each number in the sequence (default is 1).",
        "",
        "_Tip_: The `start`, `end`, and `step` can also be negative. For `start` and `end`, a negative number will index from the end of the array, where -1 is the last element. A negative `step` will simply index in the reverse direction.",
        " ",
        "For example: "
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; generate a large array.",
        "largeArray = [0:100000]",
        "",
        "; printing this normally could possibly be rather useless.",
        "; but lets say I only want to look at the first and last 5 elements.",
        "; we can print a sub array.",
        "",
        "print, largeArray[0: 4]",
        "print, largeArray[-5: *]  ; could also do [-5: -1]"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### **Modifying an Array**",
        "Once we have an **element** by the index we can modify it as if it were a **variable**. For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "example = [10:15]",
        "print, `example unchanged `",
        "print, example",
        "",
        "; access and change the first(0th) element.",
        "example[0] = -400",
        "",
        "print, `example after change `",
        "print, example"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "Whenever you reference an array element (or set of elements), you can modify that subset of data just like any other **variable**."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "ExampleVariable = 10",
        "; In IDL you can even index into a scalar number. It doesn't do anything different.",
        "; but it goes to show their similarity.",
        "print, ExampleVariable[0]",
        "",
        "example = [0:9]",
        "example[1:3] = [9, 8, 7]  ; change three elements",
        "example[5:8] = 99         ; change elements 5, 6, 7, 8 to the same value",
        "example"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "You can even index into an array using another variable. For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "array = [0:19]",
        "indices = [5, 7, 12, 18]",
        "array[indices] = -1",
        "array"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### **Array Expressions**",
        "",
        "IDL also allows you to do **array expressions**. This means you can use **IDL arrays in expressions** and expect the result to apply to **each element in the array**.  ",
        "IDL does this in C meaning it is extremely fast."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; Create and check a example array.",
        "ExampleArray = findgen(100)",
        "print, ExampleArray[1:20]",
        "",
        "; We can use this array as if it were a Variable in a Expression see 02-03",
        "ExampleArray = ExampleArray / 2 + 100",
        "",
        "print, `New values`",
        "print, ExampleArray[1:20]"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "We can do this for other operators as well."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "ExampleArray = findgen(9)",
        "",
        "ModifiedArray = findgen(9)",
        "ModifiedArray[5:7] *= 100  ; multiply these 3 elements by 100",
        "",
        "print, `Original Array`",
        "print, ExampleArray",
        "",
        "print, `ModifiedArray`",
        "print, ModifiedArray",
        "",
        "print, `Using EQ operator`",
        "print, ExampleArray eq ModifiedArray"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "As we can see here, the `EQ` **Operator** is not evaluating if the arrays are equal but is rather evaluating if the **elements in the arrays are equal**. The half that is equal (unmodified) evaluates to `1` (true), and the half that was unequal (modified) evaluates to `0` (false). In order to see if the **entire array is equal** you will need to use the **array_equal** function."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "ExampleArray = findgen(10)",
        "ModifiedArray = findgen(10)",
        "",
        "print, array_equal(ExampleArray, ModifiedArray)",
        "",
        "ModifiedArray[5:9] *= 100",
        "print, array_equal(ExampleArray, ModifiedArray)"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### Good work!",
        "That was a long one!  ",
        "Arrays are very powerful in IDL and mastering them is worth it.  "
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "cli_progress.update, 72, Text = \"Arrays down! Whats next?\""
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "Numbers are cool and all. Lets use words! [Strings](./08-Arrays.idlnb)."
      ],
      "metadata": {},
      "outputs": []
    }
  ]
}