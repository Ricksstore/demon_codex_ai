{
  "version": "2.0.0",
  "cells": [
    {
      "type": "markdown",
      "content": [
        "# Values, Types, and Variables in IDL",
        "##",
        "## **Values**",
        "A **value** is one of the fundamental building blocks of programming. Values are made of mainly letters and numbers.",
        "- A **number** (e.g., `1`, `42`, `3.14`)",
        "- A **letter** or **word** (e.g., `\"A\"`, `\"hello\"`)",
        "---",
        "## **Types**",
        "These **values** belong to different **types**. These **types** tell the computer how you want your data to be stored and interpreted.  For example:",
        "- `1.5` would be a **float**, which is a specific type of number.",
        "- `\"hello\"` would be a **string**.",
        "- There are also **compound data types** such as **structures** and **objects** that are used for more advanced data. We can ignore them for now as we will cover them later."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; To run this code, select this cell and click on the \"play\" button ",
        "; to the left of this instruction.",
        "number = 1.5",
        "word = \"Hello\"",
        "help, number",
        "help, word"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "As another exercise, we will prove that the **value** is separate from the **type**. We can do this by asking the computer to interpret the same data **value** as different **types**."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; Here is the word hello, stored as a string, as above.",
        "word = \"Hello\"",
        "",
        "; Here we are telling IDL to interpret that \"Hello\" string as a array of bytes.",
        "wordAsBytes = byte(word)",
        "print, wordAsBytes",
        "help, wordAsBytes",
        "",
        "; Look! Gobbledegook! However our value hasn't changed:",
        "; H = 72, e = 101, l = 108, l = 108, o = 111",
        "; We can see that by changing the type we don't change the data (the value).",
        "; Rather, we simply change how we want IDL to interpret it. ",
        "",
        "; To prove the data is unchanged we can convert the type back and",
        "; return the data to a form we expect.",
        "print, \"The Data lives: \" + String(wordAsBytes)"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "## **Variables**",
        "These **types** are combined with **values** to make **variables**.",
        "**Variables** are literally the named storage locations in memory. You can think of them as the \"thing\" the code uses. </br>",
        "</br>",
        "For example in the sentence:",
        "``` The basket has 3 apples. ``` </br>",
        "**Basket** would be the **Variable**, and **3** would be the **Value**.",
        "",
        "### **Variables in IDL**",
        "IDL uses **\"dynamic typing\"** to store its **values**. This makes the language easier to prototype in, simplifies the code, and helps with handling dynamic or unpredictable data. </br> </br>",
        "**What this means for you:** ",
        "In IDL, you don't need to specify the **type** of your **variable** when you create it. The type of the variable can also change depending on what you assign to it."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "x = \"String\"    ; X starts as a String",
        "help,x",
        "x = 5           ; and is now a long",
        "help,x",
        "x = 5.0         ; and is now a float",
        "help,x",
        "x = 5d          ; and is now a double",
        "help,x",
        "x = list(1,2,3) ; and is now a List Object",
        "help,x",
        "x = \"back to a String!\" ; and now its back to a string.",
        "help,x"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "This also means that the type of a variable can change depending upon what it is combined with. This is called **type promotion** and will be covered in an upcoming notebook."
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "### **Temporary Variables**",
        "",
        "In certain cases, a **temporary variable** will be used as an intermediary. This is a variable that is cleaned out of memory after it is used.",
        "",
        "Some cases include:",
        "- **Subscript and slice operations**",
        "- **Intermediate results**",
        "- **Return values from functions**  ",
        "",
        "For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "; in this example (2 + 3) evaluates separately and is stored in a temp variable (5)",
        "print, (2 + 3) * 4",
        "",
        "; so IDL processes the statement as",
        "temp = (2 + 3)",
        "print, temp * 4",
        "",
        "; create a array between 100 and 200",
        "array = [100:200]",
        "",
        "; show the first 10 elements.",
        "; In this case array[0:9] creates a temp variable.",
        "print, array[0:9]"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "",
        "### **Different IDL types.**",
        "",
        "Here are some of the basic **types** your **variable** could be:",
        "| Typecode | Data Type           | Description        |",
        "|----------|---------------------|--------------------|",
        "| 0        | Null                | An undefined variable |",
        "| 1        | Byte                | A single byte in memory |",
        "| 2        | Integer             | A short integer value |",
        "| 3        | Long                | A long integer value |",
        "| 4        | Float               | A floating-point value with about seven significant digits |",
        "| 5        | Double              | A floating-point value with about 15 significant digits |",
        "| 6        | Complex             | A real-imaginary pair of floating-point numbers |",
        "| 7        | String              | A sequence of characters (text) |",
        "| 8        | Structure           | A compound data type with tag-value pairs |",
        "| 11       | Object              | A reference to an instance of an IDL object class |",
        "",
        "",
        ""
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "> More documentation can be found here.",
        "https://www.nv5geospatialsoftware.com/docs/IDL_Data_Types.html"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "### **Key Differences**",
        "",
        "Most of IDL's types are dedicated to storing **numbers**. The difference lies in how much memory each number occupies and how the bits within each number are interpreted. This can cause confusion so let's break them down.",
        "",
        "#### Key Differences",
        "**Integer** and **Long** both use **integer values** for storage. Integer values cannot store fractions or decimal points.",
        "",
        "**Float** and **Double** both use **floating-point values** for storage. Floating-point values can store fractions but have a limited precision and suffer from roundoff errors.",
        "",
        "#### Difference between Integer and Long   ",
        "- An **IDL Integer** uses 16 \"bits\" and thus can store a value between −32,768 and 32,767.  ",
        "- An **IDL Long** uses 32 \"bits\" and thus can store a value between −2,147,483,648 and 2,147,483,647",
        "> A Long uses twice the memory of a Integer, hence the name \"Long\". IDL has even longer integers (**Long64**) and also supports unsigned versions of all of these. ",
        "",
        "#### Difference between Float and Double",
        "- An **IDL Float** uses 32 \"bits\" and can store a value between ~1.2e⁻³⁸ to 3.4e³⁸",
        "- An **IDL Double** uses 64 \"bits\" and can store a value between ~2.2e⁻³⁰⁸ to 1.8e³⁰⁸   ",
        "> A Double uses **double** the memory of Float. Making it is a **Double** float.",
        "",
        "---"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "markdown",
      "content": [
        "### **How to use the different types**",
        "In many cases, IDL will automatically determine the most appropriate data type for you. In other cases, you may need to specify the type of a constant. This is done by using a **type flag** after the constant. For example:"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "help, \"This is a string\"",
        "help, 'This is also a string'",
        "help, `An even fancier string equal to ${2 + 2}`",
        "help, 60000  ; this will automatically be a long integer",
        "help, 30000s ; this will force it to be a short integer",
        "help, 0.1 ; this will be a float",
        "help, 0.1d ; this will be a double",
        "help, 254b ; this will be a byte",
        "help, 1 + 2i ; this will be a complex number",
        "help, 1d + 2i ; this will be a double complex number"
      ],
      "metadata": {},
      "outputs": [
        {
          "items": [
            {
              "mime": "text/plain",
              "content": [
                "<Expression>    STRING    = 'This is a string'",
                "<Expression>    STRING    = 'This is also a string'",
                "<Expression>    STRING    = 'An even fancier string equal to 4'",
                "<Expression>    LONG      =        60000",
                "<Expression>    INT       =    30000",
                "<Expression>    FLOAT     =      0.100000",
                "<Expression>    DOUBLE    =       0.10000000",
                "<Expression>    BYTE      =  254",
                "<Expression>    COMPLEX   = (      1.00000,      2.00000)",
                "<Expression>    DCOMPLEX  = (       1.0000000,       2.0000000)",
                ""
              ]
            }
          ],
          "metadata": {
            "id": "not-saved"
          }
        }
      ]
    },
    {
      "type": "markdown",
      "content": [
        "___",
        "### Good work!"
      ],
      "metadata": {},
      "outputs": []
    },
    {
      "type": "code",
      "content": [
        "cli_progress.update, 9, Text = \"The journey begins!\""
      ],
      "metadata": {},
      "outputs": []
    }
  ]
}